<link href="Styles/Style00.css" rel="stylesheet" type="text/css"> <link href="Styles/Style01.css" rel="stylesheet" type="text/css"> 

# 第二章。序列的数组

> 您可能已经注意到，提到的几个操作同样适用于文本、列表和表格。文本、列表和表格一起被称为“火车”。[...】`FOR`命令通常也适用于火车。
> 
> Leo Geurts、Lambert Meertens 和 Steven Pembertonm， *ABC 程序员手册*[1]

在创建 Python 之前，Guido 是 ABC 语言的贡献者，这是一个为初学者设计编程环境的 10 年研究项目。ABC 引入了许多我们现在认为是“Pythonic 式”的思想:对不同类型的序列的一般操作、内置元组和映射类型、缩进结构、没有变量声明的强类型化等等。Python 如此人性化绝非偶然。

Python 继承了 ABC 对序列的统一处理。字符串、列表、字节序列、数组、XML 元素和数据库结果共享一组丰富的常见操作，包括迭代、切片、排序和连接。

理解 Python 中可用的各种序列使我们免于重新发明轮子，它们的公共接口激励我们创建适当支持和利用现有和未来序列类型的 API。

本章的大部分讨论一般适用于序列，从熟悉的`list`到 Python 3 中添加的`str`和`bytes`类型。列表、元组、数组和队列的具体主题也在这里讨论，但是 Unicode 字符串和字节序列的细节出现在第 4 章中。此外，这里的想法是涵盖随时可以使用的序列类型。创建你自己的序列类型是第 12 章的主题。

这些是本章将涉及的主要话题:

*   列出理解和生成器表达式的基础

*   使用元组作为记录与使用元组作为不可变列表

*   序列解包和序列模式

*   从切片读取和写入切片

*   专门化的序列类型，如数组和队列

# 本章的新内容

本章最重要的更新是“序列模式匹配”。这是 Python 3.10 的新模式匹配特性第一次出现在第二版中。

其他变化不是更新，而是对第一版的改进:

*   序列内部的新图表和描述，对比容器和扁平序列

*   `list`与`tuple`的性能和存储特性的简要比较

*   具有可变元素的元组的警告，以及如果需要如何检测它们

我把命名元组的覆盖范围移到了第五章 的 中的“经典命名元组”，在这里把它们比作`typing.NamedTuple`和`@dataclass`。

###### 注意

为了给新内容腾出空间并保持合理的页数，第一版中的“用二分法管理有序序列”部分现在是在[*fluentpython.com*](http://fluentpython.com)伙伴网站中的[帖子](https://fpy.li/bisect)。

# 内置序列概述

标准库提供了丰富的用 C 实现的序列类型选择:

Container sequences

可以容纳不同类型的物品，包括嵌套的容器。一些例子:`list`、`tuple`和`collections.deque`。

Flat sequences

保存一个简单类型的项目。一些例子:`str`、`bytes`和`array.array`。

一个 *容器序列*保存对它所包含的对象的引用，这些对象可以是任何类型，而一个*平面序列*将其内容的值存储在自己的内存空间中，而不是作为不同的 Python 对象。参见图 2-1 。

![Simplified memory diagram of an `array` and a `tuple`](Images/flpy_0201.png)

###### 图 2-1。一个`tuple`和一个`array`的简化内存图，各有三个项目。灰色单元格表示每个 Python 对象的内存中标题-未按比例绘制。`tuple`有一个对其项目的引用数组。每个项目都是一个单独的 Python 对象，可能包含对其他 Python 对象的引用，就像两个项目的列表一样。相比之下，Python `array`是一个单对象，拥有一个由三个 doubles 组成的 C 语言数组。

因此，平面序列更紧凑，但它们仅限于保存基本的机器值，如字节、整数和浮点数。

###### 注意

内存中的每个 Python 对象都有一个包含元数据的头。最简单的 Python 对象 a `float`有一个值字段和两个元数据字段:

*   `ob_refcnt`:对象的引用计数

*   `ob_type`:指向对象类型的指针

*   `ob_fval` : a C `double`持有`float`的值

在 64 位 Python 版本中，每个字段占用 8 个字节。这就是为什么浮点数组比浮点元组紧凑得多:数组是保存浮点原始值的单个对象，而元组由几个对象组成——元组本身和其中包含的每个`float`对象。

对序列类型进行分组的另一种方式是根据可变性:

Mutable sequences

以为例，`list`、`bytearray`、`array.array`和`collections.deque`。

Immutable sequences

以为例，`tuple`、`str`和`bytes`。

图 2-2 有助于可视化可变序列如何继承不可变序列的所有方法，并实现几个额外的方法。内置的具体序列类型实际上并不继承`Sequence`和`MutableSequence`抽象基类(ABCs ),但是它们是注册了这些 ABCs 的*虚拟子类*——我们将在第 13 章中看到。作为虚拟子类，`tuple`和`list`通过了这些测试:

```
>>> from collections import abc
>>> issubclass(tuple, abc.Sequence)
True
>>> issubclass(list, abc.MutableSequence)
True
```

![UML class diagram for `Sequence` and `MutableSequence`](Images/flpy_0202.png)

###### 图 2-2。【collections.abc 中一些类的简化 UML 类图(超类在左边；继承箭头从子类指向超类；斜体的名称是抽象类和抽象方法)。

记住这些共同的特征:可变的和不可变的；集装箱对平板。它们有助于将您对一种序列类型的了解推广到其他序列类型。

最基本的序列类型是`list`:一个可变容器。我想你对列表非常熟悉，所以我们将直接进入列表理解，这是一种构建列表的强大方法，但有时会因为语法乍看起来不寻常而使用不足。掌握列表理解为生成器表达式打开了大门，除其他用途外，生成器表达式可以生成元素来填充任何类型的序列。两者都是下一节的主题。

# 列表理解和生成器表达式

构建序列的一个 快速方法是使用列表理解(如果目标是`list`)或生成器表达式(对于其他类型的序列)。如果您不是每天都在使用这些语法形式，我敢打赌，您正在错过编写可读性更好、速度更快的代码的机会。

如果你怀疑我关于这些结构“可读性更好”的说法，请继续阅读。我会试着说服你。

###### 小费

为了简洁，许多 Python 程序员将列表理解称为 *listcomps* ，将生成器表达式称为*gene XP*。我也会用这些词。

## 列表理解和可读性

这里是一个测试:你觉得示例 2-1 和示例 2-2 哪个更容易读懂？

##### 示例 2-1：从字符串构建 Unicode 码位列表

```
>>> symbols = '$¢£¥€¤'
>>> codes = []
>>> for symbol in symbols:
...     codes.append(ord(symbol))
...
>>> codes
[36, 162, 163, 165, 8364, 164]
```

##### 示例 2-2：使用 listcomp 从字符串构建 Unicode 码位列表

```
>>> symbols = '$¢£¥€¤'
>>> codes = [ord(symbol) for symbol in symbols]
>>> codes
[36, 162, 163, 165, 8364, 164]
```

任何懂一点 Python 的人都可以阅读示例 2-1 。然而，在了解了 listcomps 之后，我发现示例 2-2 更具可读性，因为它的意图很明确。

一个`for`循环可以用来做许多不同的事情:扫描一个序列来计数或挑选项目，计算总数(总和、平均值)或任何数量的其他任务。示例 2-1 中的代码正在建立一个列表。相比之下，listcomp 更显而易见。它的目标总是建立一个新的列表。

当然，有可能滥用列表理解来编写真正难以理解的代码。我见过使用 listcomps 的 Python 代码，只是为了副作用而重复一段代码。如果您没有对生成的列表做任何事情，就不应该使用该语法。此外，尽量保持简短。如果列表理解跨越两行以上，最好将它分开或者重写为一个普通的`for`循环。使用您的最佳判断:对于 Python，就像对于英语一样，没有清晰写作的硬性规则。

# 语法提示

在Python 代码中，成对的`[]`、`{}`或`()`内的换行符被忽略。所以你可以建立多行列表、列表组件、元组、字典等等。，而不使用`\`行延续转义，如果您不小心在其后键入了一个空格，该转义不起作用。此外，当这些分隔符对用于定义包含逗号分隔的一系列项目的文字时，尾随的逗号将被忽略。因此，举例来说，在编写多行列表文字时，在最后一项后加一个逗号是值得考虑的，这样下一个编码人员可以更容易地向列表中添加一项，并减少读取差异时的干扰。

列表理解通过过滤和转换项目，从序列或任何其他可迭代类型构建列表。可以编写`filter`和`map`内置函数来做同样的事情，但是可读性会受到影响，我们将在下面看到。

## 列表组件与地图和过滤器

listcomps做`map`和`filter`函数所做的一切，而不会扭曲 Python `lambda`的功能。考虑示例 2-3 。

##### 示例 2-3：由 listcomp 和 map/filter 组成的相同列表

```
>>> symbols = '$¢£¥€¤'
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]
>>> beyond_ascii
[162, 163, 165, 8364, 164]
>>> beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols)))
>>> beyond_ascii
[162, 163, 165, 8364, 164]
```

我曾经认为`map`和`filter`比同等的 listcomps 要快，但是 Alex Martelli 指出事实并非如此——至少在前面的例子中不是这样。[*Fluent Python*代码库](https://fpy.li/code)中的[*02-array-seq/listcomp _ speed . py*](https://fpy.li/2-1)脚本是比较 list comp 和`filter/map`的简单速度测试。

我会在第 7 章的中对`map`和`filter`有更多的说明。现在我们转向使用 listcomps 来计算笛卡尔积:一个包含元组的列表，这些元组是从两个或更多列表中的所有项目构建的。

## 笛卡尔乘积

Listcomps 可以从两个或多个可重复项的笛卡尔积中构建列表。构成笛卡尔积的项是由来自每个输入 iterable 的项组成的元组。结果列表的长度等于输入 iterables 的长度乘以。参见图 2-3 。

![Cartesian product diagram](Images/flpy_0203.png)

###### 图 2-3。3 个牌阶和 4 个花色的笛卡儿积是 12 个配对的序列。

例如，假设您需要生成一个两种颜色和三种尺寸的 t 恤列表。示例 2-4 展示了如何使用 listcomp 生成列表。结果有六项。

##### 示例 2-4：笛卡尔积使用列表理解

```
>>> colors=['black','white']>>> sizes=['S','M','L']>>> tshirts=[(color,size)forcolorincolorsforsizeinsizes]①>>> tshirts[('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'),
 ('white', 'M'), ('white', 'L')] >>> forcolorincolors:②... forsizeinsizes:... print((color,size))...('black', 'S') ('black', 'M') ('black', 'L') ('white', 'S') ('white', 'M') ('white', 'L') >>> tshirts=[(color,size)forsizeinsizes③... forcolorincolors]>>> tshirts[('black', 'S'), ('white', 'S'), ('black', 'M'), ('white', 'M'),
 ('black', 'L'), ('white', 'L')]
```

① 这将生成一个按颜色和大小排列的元组列表。

② 注意结果列表是如何排列的，就好像`for`循环是按照它们在列表组件中出现的顺序嵌套的一样。

③ 要让项目按大小排列，然后按颜色排列，只需重新排列`for`子句；向 listcomp 添加一个换行符可以更容易地看到结果将如何排序。

在示例 1-1 ( 第 1 章)中，我使用以下表达式初始化一副牌组，该牌组由 4 种花色的全部 13 个等级的 52 张牌组成，先按花色排序，然后按等级排序:

```
        self._cards = [Card(rank, suit) for suit in self.suits
                                        for rank in self.ranks]
```

列表组件是一匹只会一招的小马:它们创建列表。要为其他序列类型生成数据，可以使用 genexp。下一节将简要介绍在构建非列表序列的背景下的 genexps。

## 生成器表达式

要初始化元组、数组和其他类型的序列，您也可以从 listcomp 开始，但是 genexp(生成器表达式)节省内存，因为它使用迭代器协议一个接一个地生成项，而不是构建一个完整的列表来提供给另一个构造函数。

Genexps 使用与 listcomps 相同的语法，但是用圆括号而不是方括号括起来。

示例 2-5 展示了 genexps 构建元组和数组的基本用法。

##### 示例 2-5：从生成器表达式初始化元组和数组

```
>>> symbols='$¢£¥€¤'>>> tuple(ord(symbol)forsymbolinsymbols)①(36, 162, 163, 165, 8364, 164) >>> importarray>>> array.array('I',(ord(symbol)forsymbolinsymbols))②array('I', [36, 162, 163, 165, 8364, 164])
```

① 如果生成器表达式是函数调用中的单个参数，则不需要重复括号。

② `array`构造函数有两个参数，所以生成器表达式两边的括号是必需的。`array`构造函数的第一个参数定义了数组中数字的存储类型，我们将在“数组”中看到。

示例 2-6 用一个带笛卡尔积的 genexp 打印出一份两种颜色三种尺寸的 T 恤衫的花名册。与示例 2-4 相比，这里的 t 恤六件商品列表从未在内存中构建:生成器表达式一次生成一件商品，并送入`for`循环。如果笛卡尔积中使用的两个列表各有 1000 个条目，那么使用生成器表达式可以节省构建一个包含 100 万个条目的列表来填充`for`循环的成本。

##### 示例 2-6：生成表达式中的笛卡尔积

```
>>> colors=['black','white']>>> sizes=['S','M','L']>>> fortshirtin(f'{c}{s}'forcincolorsforsinsizes):①... print(tshirt)...black S black M black L white S white M white L
```

① 生成器表达式逐个生成项目；在这个例子中，没有生成包含所有六种 t 恤变体的列表。

###### 注意

第 17 章详细解释了发电机的工作原理。这里的想法只是展示如何使用生成器表达式来初始化序列而不是列表，或者生成不需要保存在内存中的输出。

现在我们转到 Python 中的另一个基本序列类型:元组。

# 元组不仅仅是不可变的列表

一些关于 Python 的介绍性文本将元组呈现为“不可变列表”，但这是在贬低它们。元组有双重功能:它们可以用作不可变列表，也可以用作没有字段名的记录。这种用法有时会被忽略，所以我们将从这一点开始。

## 元组作为记录

元组保存记录:元组中的每个项保存一个字段的数据，该项的位置给出了它的含义。

如果你把一个元组想象成一个不可变的列表，条目的数量和顺序可能重要，也可能不重要，这取决于上下文。但是当使用元组作为字段集合时，项目的数量通常是固定的，它们的顺序总是很重要。

示例 2-7 显示了用作记录的元组。注意，在每个表达式中，对元组进行排序会破坏信息，因为每个字段的含义是由其在元组中的位置给出的。

##### 示例 2-7：用作记录的元组

```
>>> lax_coordinates=(33.9425,-118.408056)①>>> city,year,pop,chg,area=('Tokyo',2003,32_450,0.66,8014)②>>> traveler_ids=[('USA','31195855'),('BRA','CE342567'),③... ('ESP','XDA205856')]>>> forpassportinsorted(traveler_ids):④... print('%s/%s'%passport)⑤...BRA/CE342567 ESP/XDA205856 USA/31195855 >>> forcountry,_intraveler_ids:⑥... print(country)...USA BRA ESP
```

① 洛杉矶国际机场的经纬度。

② 关于东京的数据:名称、年份、人口(千)、人口变化(%)、面积(公里)。

③ 形式为`(country_code, passport_number)`的元组列表。

④ 当我们遍历列表时，`passport`被绑定到每个元组。

⑤ `%`格式化操作符理解元组并将每一项视为一个单独的字段。

⑥ `for`循环知道如何分别检索一个元组的条目——这被称为“解包”这里我们对第二项不感兴趣，所以我们把它赋给虚拟变量`_`。

###### 小费

一般来说，使用`_`作为虚拟变量只是惯例。它只是一个奇怪但有效的变量名。然而，在`match/case`语句中，`_`是一个通配符，它匹配任何值，但不绑定到某个值。参见“与序列的模式匹配”。在 Python 控制台中，前面命令的结果被赋给`_`——除非结果是`None`。

我们通常认为记录是带有命名字段的数据结构。第 5 章介绍了两种创建带有命名字段的元组的方法。

但是通常，没有必要为了命名字段而创建一个类，特别是如果您利用解包并避免使用索引来访问字段的话。在示例 2-7 中，我们在一条语句中将`('Tokyo', 2003, 32_450, 0.66, 8014)`赋值给`city, year, pop, chg, area`。然后，`%`操作符将`passport`元组中的每一项分配给`print`参数中格式字符串中相应的槽。以上是*元组解包*的两个例子。

###### 注意

术语tuple Unpacking 被 Pythonistas 广泛使用，但是 *iterable unpacking* 越来越受欢迎，正如标题 [PEP 3132 —扩展的 Iterable Unpacking](https://fpy.li/2-2) 。

“解包序列和可重复项”不仅介绍了解包元组，还介绍了一般的序列和可重复项。

现在让我们将`tuple`类视为`list`类的不可变变体。

## 作为不可变列表的元组

Python 解释器和标准库大量使用元组作为不可变列表，你也应该如此。这带来了两个主要好处:

Clarity

当你在代码中看到一个`tuple`时，你知道它的长度永远不会改变。

Performance

一个`tuple`比一个同样长度的`list`使用更少的内存，并且它允许 Python 做一些优化。

但是，请注意，`tuple`的不变性只适用于其中包含的引用。元组中的引用不能被删除或替换。但是如果其中一个引用指向一个可变对象，并且该对象发生了变化，那么`tuple`的值也会发生变化。下一个片段通过创建两个元组来说明这一点，这两个元组最初是相等的`a`和`b`。图 2-4 表示`b`元组在内存中的初始布局。

![Reference diagram for a tuple with three items](Images/flpy_0204.png)

###### 图 2-4。元组本身的内容是不可变的，但这仅仅意味着元组保存的引用将总是指向相同的对象。然而，如果一个被引用的对象是可变的——比如一个列表——它的内容可能会改变。

当`b`中的最后一项改变时，`b`和`a`变得不同:

```
>>> a = (10, 'alpha', [1, 2])
>>> b = (10, 'alpha', [1, 2])
>>> a == b
True
>>> b[-1].append(99)
>>> a == b
False
>>> b
(10, 'alpha', [1, 2, 99])
```

具有可变项的元组可能是错误的来源。正如我们将在“什么是可散列的”中看到的，一个对象只有在它的值永远不变时才是可散列的。不可取消的元组不能作为`dict`键或`set`元素插入。

如果您想明确地确定一个元组(或任何对象)是否有一个固定值，您可以使用内置的`hash`来创建一个`fixed`函数，如下所示:

```
>>> def fixed(o):
...     try:
...         hash(o)
...     except TypeError:
...         return False
...     return True
...
>>> tf = (10, 'alpha', (1, 2))
>>> tm = (10, 'alpha', [1, 2])
>>> fixed(tf)
True
>>> fixed(tm)
False
```

我们将在“元组的相对不变性”中进一步探讨这个问题。

尽管有这个警告，元组还是被广泛用作不可变列表。Python 核心开发人员 Raymond Hettinger 在对问题的 StackOverflow 回答中解释了它们提供的一些性能优势:[“在 Python 中元组比列表更有效吗？”](https://fpy.li/2-3)。总而言之，赫廷格写道:

*   为了评估元组文字，Python 编译器在一个操作中为元组常量生成字节码；但是对于 list literal，生成的字节码将每个元素作为单独的常量推送到数据堆栈，然后构建这个列表。

*   给定一个元组`t`，`tuple(t)`简单地返回对同一个`t`的引用。没必要复制。相反，给定一个列表`l`，构造函数`list(l)`必须创建一个`l`的新副本。

*   因为它的长度是固定的，所以一个`tuple`实例被分配了它所需要的内存空间。另一方面，`list`的实例被分配了备用空间，以摊销未来追加的成本。

*   对元组中项的引用存储在元组结构的数组中，而列表则保存指向存储在别处的引用数组的指针。间接是必要的，因为当列表增长超过当前分配的空间时，Python 需要重新分配引用数组来腾出空间。额外的间接性会降低 CPU 缓存的效率。

## 比较元组和列表方法

当 使用 tuple 作为`list`的不可变变体时，知道它们的 API 有多相似是很好的。从表 2-1 中可以看出，`tuple`支持所有不涉及添加或删除项目的`list`方法，只有一个例外——`tuple`缺少`__reversed__`方法。然而，那只是为了优化；`reversed(my_tuple)`没有它也能工作。

Table 2-1\. Methods and attributes found in `list` or `tuple` (methods implemented by object are omitted for brevity)

|  | 目录 | 元组 |   |
| --- | --- | --- | --- |
| `s.__add__(s2)` | ● | ● | `s + s2`—串联 |
| `s.__iadd__(s2)` | ● |  | `s += s2`—就地串联 |
| `s.append(e)` | ● |  | 在最后一个元素后追加一个元素 |
| `s.clear()` | ● |  | 删除所有项目 |
| `s.__contains__(e)` | ● | ● | `e in s` |
| `s.copy()` | ● |  | 列表的浅拷贝 |
| `s.count(e)` | ● | ● | 计算元素的出现次数 |
| `s.__delitem__(p)` | ● |  | 移除位置`p`处的项目 |
| `s.extend(it)` | ● |  | 从 iterable 追加项目`it` |
| `s.__getitem__(p)` | ● | ● | `s[p]`—获取位置上的项目 |
| `s.__getnewargs__()` |  | ● | 使用`pickle`支持优化的序列化 |
| `s.index(e)` | ● | ● | 找到`e`第一次出现的位置 |
| `s.insert(p, e)` | ● |  | 在位置`p`的项目前插入元素`e` |
| `s.__iter__()` | ● | ● | 获取迭代器 |
| `s.__len__()` | ● | ● | `len(s)`—项目数量 |
| `s.__mul__(n)` | ● | ● | `s * n`—重复拼接 |
| `s.__imul__(n)` | ● |  | `s *= n`—原地重复拼接 |
| `s.__rmul__(n)` | ● | ● | `n * s`—反向重复串联 [a] |
| `s.pop([p])` | ● |  | 移除并返回最后一个项目或可选位置的项目`p` |
| `s.remove(e)` | ● |  | 通过值删除第一次出现的元素`e` |
| `s.reverse()` | ● |  | 颠倒项目的顺序 |
| `s.__reversed__()` | ● |  | 获取迭代器从最后一个到第一个扫描项目 |
| `s.__setitem__(p, e)` | ● |  | `sp] = e`—将`e`置于`p`位置，覆盖现有的 ^([b) |
| `s.sort([key], [reverse])` | ● |  | 使用可选的关键字参数`key`和`reverse`对项目进行排序 |
| ^(a](ch02.xhtml#idm46582502610224-marker)) 反转运算符在第十六章中有解释。[b] 也用于覆盖一个子序列。参见[“分配给切片”。 |

现在让我们切换到一个惯用 Python 编程的重要主题:元组、列表和可迭代解包。

# 解包序列和可重复项

解包 很重要，因为它避免了不必要的和容易出错的使用索引从序列中提取元素。此外，解包可以使用任何可迭代对象作为数据源，包括不支持 索引符号(`]`)的迭代器。唯一的要求是 iterable 在接收端为每个变量产生一个项目，除非你使用星号(`*`)来捕获多余的项目，如[“使用*来抓取多余的项目”中所解释的。

最明显的解包形式是*并行赋值*；也就是说，将 iterable 中的项分配给变量元组，如下例所示:

```
>>> lax_coordinates = (33.9425, -118.408056)
>>> latitude, longitude = lax_coordinates  # unpacking
>>> latitude
33.9425
>>> longitude
-118.408056
```

解包的一个优雅的应用是交换变量的值，而不使用临时变量:

```
>>> b, a = a, b
```

解包的另一个例子是在调用函数时在参数前加上`*`

```
>>> divmod(20, 8)
(2, 4)
>>> t = (20, 8)
>>> divmod(*t)
(2, 4)
>>> quotient, remainder = divmod(*t)
>>> quotient, remainder
(2, 4)
```

前面的代码展示了解包的另一种用法:允许函数以方便调用者的方式返回多个值。作为另一个例子，`os.path.split()`函数从文件系统路径构建一个元组`(path, last_part)`:

```
>>> import os
>>> _, filename = os.path.split('/home/luciano/.ssh/id_rsa.pub')
>>> filename
'id_rsa.pub'
```

另一种在解包时只使用某些项目的方法是使用`*`语法，我们马上就会看到。

## 使用*抓取多余的项目

用`*args`定义 函数参数来抓取任意多余的实参是经典的 Python 特性。

在 Python 3 中，这一思想被扩展到应用于并行赋值:

```
>>> a, b, *rest = range(5)
>>> a, b, rest
(0, 1, [2, 3, 4])
>>> a, b, *rest = range(3)
>>> a, b, rest
(0, 1, [2])
>>> a, b, *rest = range(2)
>>> a, b, rest
(0, 1, [])
```

在并行赋值的上下文中，`*`前缀只能应用于一个变量，但它可以出现在任何位置:

```
>>> a, *body, c, d = range(5)
>>> a, body, c, d
(0, [1, 2], 3, 4)
>>> *head, b, c, d = range(5)
>>> head, b, c, d
([0, 1], 2, 3, 4)
```

## 在函数调用和序列文本中用*解包

[PEP 448—额外的解包一般化](https://fpy.li/pep448)引入了更灵活的可迭代解包语法，在[“Python 3.5 中的新特性”](https://fpy.li/2-4)中做了最好的总结。

在函数调用中，我们可以多次使用`*`:

```
>>> def fun(a, b, c, d, *rest):
...     return a, b, c, d, rest
...
>>> fun(*[1, 2], 3, *range(4, 7))
(1, 2, 3, 4, (5, 6))
```

在定义`list`、`tuple`或`set`文字时，也可以使用`*`，如这些来自[“Python 3.5 中的新特性”](https://fpy.li/2-4)的例子所示:

```
>>> *range(4), 4
(0, 1, 2, 3, 4)
>>> [*range(4), 4]
[0, 1, 2, 3, 4]
>>> {*range(4), 4, *(5, 6, 7)}
{0, 1, 2, 3, 4, 5, 6, 7}
```

PEP 448 为`**`引入了类似的新语法，我们将在“解包映射”中看到。

最后，元组解包的一个强大特性是它可以处理嵌套结构。

## 嵌套拆包

解包的目标可以使用嵌套，例如`(a, b, (c, d))`。如果值有相同的嵌套结构，Python 会做正确的事情。示例 2-8 显示了嵌套拆包的操作。

##### 示例 2-8：解包嵌套元组以访问经度

```
metro_areas=[('Tokyo','JP',36.933,(35.689722,139.691667)),①('Delhi NCR','IN',21.935,(28.613889,77.208889)),('Mexico City','MX',20.142,(19.433333,-99.133333)),('New York-Newark','US',20.104,(40.808611,-74.020386)),('São Paulo','BR',19.649,(-23.547778,-46.635833)),]defmain():print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')forname,_,_,(lat,lon)inmetro_areas:②iflon<=0:③print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')if__name__=='__main__':main()
```

① 每个元组保存一个包含四个字段的记录，最后一个字段是一个坐标对。

② 通过将最后一个字段分配给嵌套元组，我们解包了坐标。

③ 测试只选择了西半球的城市。

示例 2-8 的输出为:

```
                |  latitude | longitude
Mexico City     |   19.4333 |  -99.1333
New York-Newark |   40.8086 |  -74.0204
São Paulo       |  -23.5478 |  -46.6358
```

解包任务的目标也可以是一个列表，但是很少有好的用例。下面是我知道的唯一一个:如果您有一个返回单个记录的数据库查询(例如，SQL 代码有一个`LIMIT 1`子句)，那么您可以解包，同时确保这段代码只有一个结果:

```
>>> [record] = query_returning_single_row()
```

如果记录只有一个字段，您可以直接获取它，如下所示:

```
>>> [[field]] = query_returning_single_row_with_single_field()
```

这两者都可以用元组来编写，但是不要忘记语法上的怪癖，即单项式元组必须用尾随逗号来编写。所以第一个目标是`(record,)`，第二个是`((field,),)`。在这两种情况下，如果你忘记了一个逗号，你会得到一个无声的错误。 [3]

现在让我们研究模式匹配，它支持更强大的解包序列的方法。

# 序列模式匹配

Python 3.10 中 最明显的新特性是模式匹配，使用了[PEP 634—结构化模式匹配:规范](https://fpy.li/pep634)中提出的`match/case`语句。

###### 注意

Python 核心开发者 Carol Willing 在“Python 3.10 新特性”](https://fpy.li/2-7)的[“结构化模式匹配”](https://fpy.li/2-6)部分写了关于模式匹配的精彩介绍。你可能想看看那个快速概述。在本书中，我选择将模式匹配的覆盖范围划分到不同的章节，这取决于模式类型:[“带有映射的模式匹配”和“模式匹配类实例”。一个扩展示例在“lis . py 中的模式匹配:案例研究”中。

这里是`match/case`处理序列的第一个例子。想象一下，你正在设计一个机器人，它接受以单词和数字序列形式发送的命令，就像`BEEPER 440 3`一样。在分成几个部分并解析数字之后，您将得到类似于`['BEEPER', 440, 3]`的消息。您可以使用这样的方法来处理这样的消息:

##### 示例 2-9：方法来自一个假想的`Robot`类

```
defhandle_command(self,message):matchmessage:①case['BEEPER',frequency,times]:②self.beep(times,frequency)case['NECK',angle]:③self.rotate_neck(angle)case['LED',ident,intensity]:④self.leds[ident].set_brightness(ident,intensity)case['LED',ident,red,green,blue]:⑤self.leds[ident].set_color(ident,red,green,blue)case_:⑥raiseInvalidCommand(message)
```

① `match`关键字后的表达式是*主语*。主题是 Python 将尝试匹配每个`case`子句中的模式的数据。

② 该模式匹配任何包含三个项目的序列主题。第一项必须是字符串`'BEEPER'`。第二项和第三项可以是任何东西，它们将按顺序绑定到变量`frequency`和`times`。

③ 这匹配任何具有两个项目的主题，第一个是`'NECK'`。

④ 这将匹配一个包含三个以`'LED'`开头的条目的主题。如果条目的数量不匹配，Python 将继续下一个`case`。

⑤ 另一个序列模式从`'LED'`开始，现在有五个项目——包括`'LED'`常量。

⑥ 这是默认的`case`。它将匹配任何与先前模式不匹配的主题。正如我们很快会看到的，变量`_`是特殊的。

在的表面上，`match/case`可能看起来像 C 语言中的`switch/case`语句——但这只是故事的一半。[4]`match`相对于`switch`的一个关键改进是 *析构*——一种更高级的解包形式。析构是 Python 词汇表中的一个新词，但它通常用于支持模式匹配的语言的文档中，如 Scala 和 Elixir。

作为解构的第一个例子，示例 2-10 展示了用`match/case`改写的示例 2-8 的一部分。

##### 示例 2-10：析构嵌套元组—要求 Python ≥ 3.10

```
metro_areas=[('Tokyo','JP',36.933,(35.689722,139.691667)),('Delhi NCR','IN',21.935,(28.613889,77.208889)),('Mexico City','MX',20.142,(19.433333,-99.133333)),('New York-Newark','US',20.104,(40.808611,-74.020386)),('São Paulo','BR',19.649,(-23.547778,-46.635833)),]defmain():print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')forrecordinmetro_areas:matchrecord:①case[name,_,_,(lat,lon)]iflon<=0:②print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
```

① 这个`match`的主题是`record`，即`metro_areas`中的每个元组。

② 一个`case`子句有两个部分:一个模式和一个带有`if` 关键字的可选保护。

一般来说，如果满足以下条件，序列模式与主题匹配:

1.  主题是一个序列*和*；

2.  主题和图案的项数相同*和*；

3.  每个对应的项目都匹配，包括嵌套的项目。

例如示例 2-10 中的`[name, _, _, (lat, lon)]`模式匹配一个四项序列，最后一项必须是两项序列。

序列模式可以写成元组或者列表，或者嵌套元组和列表的任意组合，但是使用哪种语法没有区别:在序列模式中，方括号和圆括号的意思是一样的。我把模式写成一个嵌套的 2 元组列表，只是为了避免在示例 2-10 中重复括号或圆括号。

除了`str`、`bytes`和`bytearray`之外，序列模式可以匹配`collections.abc.Sequence`的大多数实际或虚拟子类的实例。

###### 警告

在`match/case`的上下文中，`str`、`bytes`和`bytearray`的实例不作为序列处理。其中一种类型的`match`主题被视为“原子”值——就像整数 987 被视为一个值，而不是一个数字序列。将这三种类型视为序列可能会由于意外匹配而导致错误。如果您想将这些类型的对象视为序列主题，请在`match`子句中转换它。例如，参见后面的中的`tuple(phone)`:

```
    match tuple(phone):
        case ['1', *rest]:  # North America and Caribbean
            ...
        case ['2', *rest]:  # Africa and some territories
            ...
        case ['3' | '4', *rest]:  # Europe
            ...
```

在标准库中，这些类型与序列模式兼容:

```
list     memoryview    array.array
tuple    range         collections.deque
```

与解包不同，模式不会析构不是序列的可迭代对象(比如迭代器)。

`_`符号在模式上是特殊的:它匹配该位置的任何单个项目，但它从不绑定到匹配项目的值。另外，`_`是唯一一个可以在一个模式中出现不止一次的变量。

您可以使用 `as`关键字将模式的任何部分与变量绑定:

```
        case [name, _, _, (lat, lon) as coord]:
```

给定主题`['Shanghai', 'CN', 24.9, (31.1, 121.3)]`，前面的模式将匹配，并设置以下变量:

| 可变的 | 给定值 |
| --- | --- |
| `name` | `'Shanghai'` |
| `lat` | `31.1` |
| `lon` | `121.3` |
| `coord` | `(31.1, 121.3)` |

我们可以通过添加类型信息来使模式更加具体。例如，以下模式匹配与上一个示例相同的嵌套序列结构，但是第一个项目必须是`str`的实例，并且 2 元组中的两个项目都必须是`float`的实例:

```
        case [str(name), _, _, (float(lat), float(lon))]:
```

###### 小费

表达式`str(name)`和`float(lat)`看起来像构造函数调用，我们用它们将`name`和`lat`转换成`str`和`float`。但是在模式的上下文中，该语法执行运行时类型检查:前面的模式将匹配一个四项序列，其中项 0 必须是一个`str`，项 3 必须是一对浮点。另外，项 0 中的`str`将被绑定到`name`变量，项 3 中的浮点将分别被绑定到`lat`和`lon`。因此，尽管`str(name)`借用了构造函数调用的语法，但是在模式的上下文中，语义是完全不同的。在模式中使用任意类将在“模式匹配类实例”中介绍。

另一方面，如果我们想要匹配任何以`str`开始，以两个浮点的嵌套序列结束的主题序列，我们可以写:

```
        case [str(name), *_, (float(lat), float(lon))]:
```

`*_`匹配任意数量的项目，而不将它们绑定到变量。使用`*extra`而不是`*_`会将项目绑定到`extra`作为具有 0 个或更多项目的`list`。

以`if`开头的可选 guard 子句只有在模式匹配时才会被求值，并且可以引用模式中绑定的变量，如示例 2-10 所示:

```
        match record:
            case [name, _, _, (lat, lon)] if lon <= 0:
                print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
```

只有当模式匹配且保护表达式为*真值*时，带有`print`语句的嵌套块才会运行。

###### 小费

用模式进行析构是如此富于表现力，以至于有时一个带有单个`case`的`match`可以使代码更简单。吉多·范·罗苏姆收集了一系列的`case/match`例子，其中包括一个他命名为[“带有抽取的非常深的可迭代和类型匹配”](https://fpy.li/2-10)。

示例 2-10 不是对示例 2-8 的改进。这只是一个对比做同一件事的两种方法的例子。下一个例子展示了模式匹配如何有助于清晰、简洁和有效的代码。

## 解释程序中的模式匹配序列

斯坦福大学的彼得·诺维格 写了 [*lis.py*](https://fpy.li/2-11) :一个解释器，用 132 行漂亮易读的 Python 代码解释了 Lisp 编程语言的 Scheme 方言子集。我把 Norvig 的 MIT 授权的源码更新到 Python 3.10 来展示模式匹配。在这一节中，我们将比较 Norvig 代码的一个关键部分——它使用了`if/elif`和解包——和使用了`match/case`的重写。

*lis.py* 的两个主要功能是`parse`和`evaluate`。解析器接受带括号的表达式并返回 Python 列表。这里有两个例子:

```
>>> parse('(gcd 18 45)')
['gcd', 18, 45]
>>> parse('''
... (define double
...     (lambda (n)
...         (* n 2)))
... ''')
['define', 'double', ['lambda', ['n'], ['*', 'n', 2]]]
```

评估器获取这样的列表并执行它们。第一个例子是用`18`和`45`作为参数调用一个`gcd`函数。计算时，它会计算参数的最大公约数:9。第二个例子是用参数`n`定义一个名为`double`的函数。函数的主体是表达式`(* n 2)`。在 Scheme 中调用一个函数的结果是其体中最后一个表达式的值。

我们这里的重点是析构序列，所以我不会解释求值器的动作。参见“lis . py 中的模式匹配:案例研究”了解更多关于 *lis.py* 如何工作的信息。

示例 2-11 显示了 Norvig 的赋值器，略有改动，缩写后仅显示序列模式。

##### 示例 2-11：匹配图案无需`match/case`

```
def evaluate(exp: Expression, env: Environment) -> Any:
    "Evaluate an expression in an environment."
    if isinstance(exp, Symbol):      # variable reference
        return env[exp]
    # ... lines omitted
    elif exp[0] == 'quote':          # (quote exp)
        (_, x) = exp
        return x
    elif exp[0] == 'if':             # (if test conseq alt)
        (_, test, consequence, alternative) = exp
        if evaluate(test, env):
            return evaluate(consequence, env)
        else:
            return evaluate(alternative, env)
    elif exp[0] == 'lambda':         # (lambda (parm…) body…)
        (_, parms, *body) = exp
        return Procedure(parms, body, env)
    elif exp[0] == 'define':
        (_, name, value_exp) = exp
        env[name] = evaluate(value_exp, env)
    # ... more lines omitted
```

注意每个`elif`子句如何检查列表的第一项，然后忽略第一项，打开列表。解包的广泛使用表明 Norvig 是模式匹配的爱好者，但他最初是为 Python 2 编写代码的(尽管现在它可以在任何 Python 3 上工作)。

在 Python ≥ 3.10 中使用`match/case`，我们可以重构`evaluate`如示例 2-12 所示。

##### 示例 2-12：与`match/case`模式匹配—要求 Python ≥ 3.10

```
defevaluate(exp:Expression,env:Environment)->Any:"Evaluate an expression in an environment."matchexp:# ... lines omittedcase['quote',x]:①returnxcase['if',test,consequence,alternative]:②ifevaluate(test,env):returnevaluate(consequence,env)else:returnevaluate(alternative,env)case['lambda',[*parms],*body]ifbody:③returnProcedure(parms,body,env)case['define',Symbol()asname,value_exp]:④env[name]=evaluate(value_exp,env)# ... more lines omittedcase_:⑤raiseSyntaxError(lispstr(exp))
```

① 如果主题是以`'quote'`开始的两项序列，则匹配。

② 如果主题是以`'if'`开始的四项序列，则匹配。

③ 如果主题是以`'lambda'`开始的三个或更多项目的序列，则匹配。防护装置确保`body`不是空的。

④ 如果 subject 是一个以`'define'`开头的三项序列，后跟一个`Symbol`实例，则匹配。

⑤ 拥有一个包罗万象的`case`是个好习惯。在这个例子中，如果`exp`与任何模式都不匹配，那么表达式就是畸形的，我抛出`SyntaxError`。

如果没有一个总括，当一个主题与任何情况都不匹配时，整个`match`语句就什么也做不了——这可能是一个无声的失败。

Norvig 故意避免在 *lis.py* 中进行错误检查，以使代码易于理解。有了模式匹配，我们可以添加更多的检查，并且仍然保持它的可读性。例如，在`'define'`模式中，原始代码不能确保`name`是`Symbol`的实例——这需要一个`if`块、一个`isinstance`调用和更多代码。示例 2-12 比示例 2-11 更短更安全。

### lambda 的替代模式

这是 Scheme 中`lambda`的语法，使用后缀`…`表示元素可能出现零次或多次的语法约定:

```
(lambda (parms…) body1 body2…)
```

lambda 案例`'lambda'`的一个简单模式是:

```
       case ['lambda', parms, *body] if body:
```

但是，它匹配`parms`位置中的任何值，包括该无效主题中的第一个`'x'`:

```
['lambda', 'x', ['*', 'x', 2]]
```

Scheme 中`lambda`关键字后的嵌套列表保存了函数的形参名称，即使它只有一个元素，也必须是一个列表。如果函数没有参数，它也可能是一个空列表——就像 Python 的`random.random()`。

在示例 2-12 中，我使用嵌套序列模式使`'lambda'`模式更安全:

```
        case ['lambda', [*parms], *body] if body:
            return Procedure(parms, body, env)
```

在一个序列模式中，`*`在每个序列中只能出现一次。这里我们有两个序列:外部序列和内部序列。

在`parms`周围添加字符`[*]`使得模式看起来更像它处理的 Scheme 语法，并给了我们额外的结构检查。

### 函数定义的快捷语法

Scheme 有一个替代的`define`语法来创建一个命名函数，而不使用嵌套的`lambda`。这是语法:

```
(define (name parm…) body1 body2…)
```

关键字`define`后面是一个列表，其中包含新函数的`name`以及零个或多个参数名。在这个列表之后是带有一个或多个表达式的函数体。

将这两行添加到`match`负责实现:

```
        case ['define', [Symbol() as name, *parms], *body] if body:
            env[name] = Procedure(parms, body, env)
```

我会将该`case`放在示例 2-12 中另一个`define`案例之后。在这个例子中，`define`案例之间的顺序是不相关的，因为没有主题可以同时匹配这两种模式:第二个元素必须是原始`define`案例中的`Symbol`，但是它必须是以函数定义的`define`快捷方式中的`Symbol`开始的序列。

现在考虑一下，在示例 2-11 中，如果没有模式匹配的帮助，我们要增加对第二个`define`语法的支持需要做多少工作。在类 C 语言中,`match`语句比`switch`做得更多。

模式匹配是声明式编程的一个例子:代码描述了你想匹配“什么”,而不是“如何”匹配。代码的形状遵循数据的形状，如表 2-2 所示。

Table 2-2\. Some Scheme syntactic forms and `case` patterns to handle them

| 方案语法 | 序列模式 |
| --- | --- |
| `(quote exp)` | `['quote', exp]` |
| `(if test conseq alt)` | `['if', test, conseq, alt]` |
| `(lambda (parms…) body1 body2…)` | `['lambda', [*parms], *body] if body` |
| `(define name exp)` | `['define', Symbol() as name, exp]` |
| `(define (name parms…) body1 body2…)` | `['define', [Symbol() as name, *parms], *body] if body` |

我希望 Norvig 的`evaluate`对模式匹配的重构能让你相信`match/case`能让你的代码更易读、更安全。

###### 注意

我们将在“lis . py 中的模式匹配:案例研究”中看到更多 *lis.py* ，届时我们将在`evaluate`中查看完整的`match/case`示例。如果你想了解更多关于 Norvig 的 *lis.py* ，请阅读他的精彩帖子[(如何写一个(Lisp)解释器(用 Python))](https://fpy.li/2-12)。

这就结束了我们的第一次解包、析构和序列模式匹配之旅。我们将在后面的章节中讨论其他类型的模式。

每个 Python 程序员都知道可以使用`s[a:b]`语法对序列进行切片。我们现在转向一些不太为人所知的关于切片的事实。

# 限幅

Python 中的`list`、`tuple`、`str`以及所有序列类型的一个共同特点就是对切片操作的支持，这比大多数人意识到的要强大。

在本节中，我们将描述这些高级切片形式的*使用*。它们在用户定义类中的实现将在第 12 章中介绍，这与我们在本书的这一部分中介绍现成类以及在[第三部分](part03.xhtml#classes_protocols_part)中创建新类的理念相一致。

## 为什么切片和区域排除最后一项

Python 中排除切片和范围中最后一项的约定与 Python、C 和许多其他语言中使用的从零开始的索引配合得很好。该公约的一些便利特征是:

*   当只给定停止位置时，很容易看到一个切片或范围的长度:`range(3)`和`my_list[:3]`都产生三个项目。

*   当给定开始和停止时，很容易计算切片或范围的长度:只需减去`stop - start`。

*   很容易在任何索引`x`处将一个序列分成两部分，没有重叠:只需得到`my_list[:x]`和`my_list[x:]`。例如:

    ```
    >>> l = [10, 20, 30, 40, 50, 60]
    >>> l[:2]  # split at 2
    [10, 20]
    >>> l[2:]
    [30, 40, 50, 60]
    >>> l[:3]  # split at 3
    [10, 20, 30]
    >>> l[3:]
    [40, 50, 60]
    ```

荷兰计算机科学家 Edsger W. Dijkstra 为这一惯例撰写了最好的论据(参见“进一步阅读”中的最后一个参考文献)。

现在让我们仔细看看 Python 是如何解释切片符号的。

## 切片对象

这个不是秘密，但是值得重复一下以防万一:`s[a:b:c]`可以用来指定一个步幅或步骤`c`，导致结果切片跳过项目。跨距也可以是负的，以相反的方向返回项目。三个例子说明了这一点:

```
>>> s = 'bicycle'
>>> s[::3]
'bye'
>>> s[::-1]
'elcycib'
>>> s[::-2]
'eccb'
```

另一个例子在第 1 章中显示，当时我们使用`deck[12::13]`拿到了未洗牌的所有 a:

```
>>> deck[12::13]
[Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'),
Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]
```

符号`a:b:c`仅在用作索引或下标操作符时在`]`内有效，它产生一个切片对象:`slice(a, b, c)`。正如我们将在[“切片如何工作”中看到的，为了评估表达式`seq[start:stop:step]`，Python 调用了`seq.__getitem__(slice(start, stop, step))`。即使您没有实现自己的序列类型，了解切片对象也是有用的，因为它允许您为切片指定名称，就像电子表格允许命名单元格区域一样。

假设您需要解析像示例 2-13 中所示的发票这样的平面文件数据。您可以给代码命名，而不是用硬编码的片段填充代码。看看这个例子末尾的`for`循环的可读性如何。

##### 示例 2-13：平面文件发票的行项目

```
>>> invoice = """
... 0.....6.................................40........52...55........
... 1909  Pimoroni PiBrella                     $17.50    3    $52.50
... 1489  6mm Tactile Switch x20                 $4.95    2     $9.90
... 1510  Panavise Jr. - PV-201                 $28.00    1    $28.00
... 1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
... """
>>> SKU = slice(0, 6)
>>> DESCRIPTION = slice(6, 40)
>>> UNIT_PRICE = slice(40, 52)
>>> QUANTITY =  slice(52, 55)
>>> ITEM_TOTAL = slice(55, None)
>>> line_items = invoice.split('\n')[2:]
>>> for item in line_items:
...     print(item[UNIT_PRICE], item[DESCRIPTION])
...
 $17.50   Pimoroni PiBrella
 $4.95   6mm Tactile Switch x20
 $28.00   Panavise Jr. - PV-201
 $34.95   PiTFT Mini Kit 320x240
```

当我们在“Vector Take # 2:A Sliceable Sequence”中讨论创建自己的集合时，我们将回到`slice`对象。同时，从用户的角度来看，切片还包含了其他特性，比如多维切片和省略号(`...`)符号。请继续阅读。

## 多维切片和省略

`[]`操作符 也可以接受多个索引或切片，用逗号分隔。处理`[]`操作符的 `__getitem__`和`__setitem__`特殊方法只是将`a[i, j]`中的索引作为一个元组接收。换句话说，为了评估`a[i, j]`，Python 调用了`a.__getitem__((i, j))`。

例如，这在外部 NumPy 包中使用，其中可以使用语法`ai, j]`获取二维`numpy.ndarray`的项目，并使用类似于`a[m:n, k:l]`的表达式获取二维切片。[本章后面的例子 2-22 展示了这种符号的用法。

除了`memoryview`之外，Python 内置的序列类型都是一维的，所以它们只支持一个索引或者片，不支持它们的元组。 [6]

省略号——用三个句号(`...`)而不是`…` (Unicode U+2026)写成——被 Python 解析器识别为一个标记。它是`Ellipsis`对象的别名，是`ellipsis`类的单个实例。 [7] 同样，它可以作为函数的参数传递，也可以作为切片规范的一部分，如在`f(a, ..., z)`或`a[i:...]`中。NumPy 在对多维数组切片时使用`...`作为快捷方式；比如`x`是四维数组，`x[i, ...]`就是`x[i, :, :, :,]`的快捷方式。参见[“NumPy 快速入门”](https://fpy.li/2-13)了解更多相关信息。

在撰写本文时，我还不知道在 Python 标准库中使用了`Ellipsis`或多维索引和切片。如果你发现一个，让我知道。这些语法特性的存在是为了支持用户定义的类型和扩展，比如 NumPy。

切片不仅有助于从序列中提取信息；它们也可以用来就地改变可变序列——也就是说，不需要从头开始重建它们。

## 分配给切片

可变的序列可以被移植、删除，或者使用赋值语句左边的切片符号或者作为`del`语句的目标进行修改。接下来的几个例子展示了这种符号的威力:

```
>>> l=list(range(10))>>> l[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> l[2:5]=[20,30]>>> l[0, 1, 20, 30, 5, 6, 7, 8, 9] >>> dell[5:7]>>> l[0, 1, 20, 30, 5, 8, 9] >>> l[3::2]=[11,22]>>> l[0, 1, 20, 11, 5, 22, 9] >>> l[2:5]=100①Traceback (most recent call last):
 File "<stdin>", line 1, in <module>TypeError: can only assign an iterable>>> l[2:5]=[100]>>> l[0, 1, 100, 22, 9]
```

① 当赋值的目标是一个切片时，右边必须是一个 iterable 对象，即使它只有一个项。

每个编码者都知道串联是序列的常见操作。Python 入门教程解释了如何使用`+`和`*`来达到这个目的，但是还有一些关于它们如何工作的微妙细节，我们将在接下来讨论。

# 对序列使用+和*

Python 程序员期望序列支持`+`和`*`。通常`+`的两个操作数必须是相同的序列类型，它们都不被修改，但是一个相同类型的新序列作为连接的结果被创建。

要连接同一序列的多个副本，请将其乘以一个整数。再次创建一个新序列:

```
>>> l = [1, 2, 3]
>>> l * 5
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> 5 * 'abcd'
'abcdabcdabcdabcdabcd'
```

`+`和`*`总是创建一个新对象，并且从不改变它们的操作数。

###### 警告

当`a`是一个包含可变项的序列时，要小心像`a * n`这样的表达式，因为结果可能会让你吃惊。例如，试图将一个列表初始化为`my_list = [[]] * 3`，将导致一个列表有三个对同一个内部列表的引用，这可能不是您想要的。

下一节将介绍试图使用`*`来初始化列表的陷阱。

## 构建列表的列表

有时我们需要用一定数量的嵌套列表初始化一个列表——例如，将学生分配到一个团队列表中，或者在游戏棋盘上表示方块。这样做的最好方法是列表理解，如示例 2-14 所示。

##### 示例 2-14：包含三个长度为 3 的列表的列表可以代表一个井字游戏棋盘

```
>>> board=[['_']*3foriinrange(3)]①>>> board[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']] >>> board[1][2]='X'②>>> board[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
```

① 创建三个列表，每个列表包含三个项目。检查结构。

② 在第 1 行第 2 列做一个标记，并检查结果。

一个诱人但错误的捷径是像示例 2-15 那样做。

##### 示例 2-15：对同一个列表有三个引用的列表是没有用的

```
>>> weird_board=[['_']*3]*3①>>> weird_board[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']] >>> weird_board[1][2]='O'②>>> weird_board[['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]
```

① 外部列表由对同一个内部列表的三个引用组成。虽然没有改变，但一切似乎都是正确的。

② 在第 1 行第 2 列放置一个标记，显示所有行都是引用同一对象的别名。

示例 2-15 的问题在于，本质上，它的行为类似于下面的代码:

```
row=['_']*3board=[]foriinrange(3):board.append(row)①
```

① 相同的`row`被三次附加到`board`上。

另一方面，来自示例 2-14 的列表理解等价于此代码:

```
>>>board=[]>>>foriinrange(3):...row=['_']*3①...board.append(row)...>>>board[['_','_','_'],['_','_','_'],['_','_','_']]>>>board[2][0]='X'>>>board②[['_','_','_'],['_','_','_'],['X','_','_']]
```

① 每次迭代都构建一个新的`row`，并将其附加到`board`。

② 正如所料，只有第 2 行发生了变化。

###### 小费

如果你对这一部分的问题或解决方案不清楚，请放松。写第 6 章是为了阐明引用和可变对象的机制和陷阱。

到目前为止，我们已经讨论了普通的`+`和`*`操作符对序列的使用，但是还有`+=`和`*=`操作符，它们根据目标序列的可变性产生非常不同的结果。下一节解释了它是如何工作的。

## 用序列扩充赋值

增强赋值运算符`+=`和`*=`的行为完全不同，这取决于第一个操作数。为了简化讨论，我们将首先关注增强加法(`+=`)，但是这些概念也适用于`*=`和其他增强赋值操作符。

使`+=`起作用的特殊方法是`__iadd__`(用于“就地添加”)。

但是，如果`__iadd__`没有实现，Python 就退回到调用`__add__`。考虑这个简单的表达式:

```
>>> a += b
```

如果`a`实现了`__iadd__`，那么就会被调用。在可变序列的情况下(例如，`list`、`bytearray`、`array.array`)，`a`将被原地改变(即效果将类似于`a.extend(b)`)。但是，当`a`没有实现`__iadd__`时，表达式`a += b`的效果和`a = a + b`一样:首先对表达式`a + b`求值，产生一个新的对象，然后绑定到`a`。换句话说，绑定到`a`的对象的的身份可能会改变，也可能不会改变，这取决于`__iadd__`的可用性。

一般来说，对于可变序列，最好是实现`__iadd__`并且在适当的位置发生`+=`。对于不可变的序列，显然不可能发生这种情况。

我刚才写的关于`+=`的内容也适用于`*=`，它是通过`__imul__`实现的。第 16 章的中讨论了`__iadd__`和`__imul__`特殊方法。下面是一个使用可变序列和不可变序列的`*=`的演示:

```
>>> l=[1,2,3]>>> id(l)4311953800 ①>>> l*=2>>> l[1, 2, 3, 1, 2, 3] >>> id(l)4311953800 ②>>> t=(1,2,3)>>> id(t)4312681568 ③>>> t*=2>>> id(t)4301348296 ④
```

① 初始列表的 ID。

② 相乘后，列表是相同的对象，只是添加了新的项。

③ 初始元组的 ID。

④ 相乘后，创建了一个新的元组。

不可变序列的重复连接是低效的，因为解释器不是仅仅追加新的项，而是必须复制整个目标序列，用连接的新项创建一个新序列。 [8]

我们已经看到了`+=`的常见用例。下一节展示了一个有趣的案例，突出了“不可变”在元组上下文中的真正含义。

## 分配难题

不使用控制台试着回答:对示例 2-16 中的两个表达式求值的结果是什么？ [9]

##### 示例 2-16：一个谜

```
>>> t = (1, 2, [30, 40])
>>> t[2] += [50, 60]
```

接下来会发生什么？选择最佳答案:

1.  `t`变成了`(1, 2, [30, 40, 50, 60])`。

2.  `TypeError`被消息`'tuple' object does not support item assignment`唤醒。

3.  都不是。

4.  A 和 b 都是。

我看到这个的时候很确定答案是 B，其实是 D，“A 和 B 都有”！示例 2-17 是 Python 3.9 控制台的实际输出。 [10]

##### 示例 2-17：意外结果:项目 T2 被更改*且*出现异常

```
>>> t = (1, 2, [30, 40])
>>> t[2] += [50, 60]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> t
(1, 2, [30, 40, 50, 60])
```

在线 Python 导师](https://fpy.li/2-14)是一个非常棒的在线工具，可以形象地展示 Python 如何详细工作。[图 2-5 是两张截图的合成图，显示了来自示例 2-17 的元组`t`的初始和最终状态。

![References diagram](Images/flpy_0205.png)

###### 图 2-5。元组赋值 puzzler 的初始和最终状态(在线 Python 导师生成的图)。

如果你看一下 Python 为表达式`sa] += b` ( [示例 2-18 )生成的字节码，就会清楚这是如何发生的。

##### 示例 2-18：表达式的字节码`s[a] += b`

```
>>> dis.dis('s[a] += b') 1           0 LOAD_NAME                0 (s) 3 LOAD_NAME                1 (a) 6 DUP_TOP_TWO 7 BINARY_SUBSCR ① 8 LOAD_NAME                2 (b) 11 INPLACE_ADD ② 12 ROT_THREE 13 STORE_SUBSCR ③ 14 LOAD_CONST               0 (None) 17 RETURN_VALUE
```

① 将`s[a]`的值放在`TOS`上(栈顶)。

② 执行`TOS += b`。如果`TOS`引用了一个可变对象(在示例 2-17 中，它是一个列表)，那么这就成功了。

③ 分配`sa] = TOS`。如果`s`是不可变的(示例 2-17[中的`t`元组)，这将失败。

这个例子是一个很小的例子——在使用 Python 的 20 年中，我从未见过这种奇怪的行为真的咬人。

我从中吸取了三个教训:

*   避免将可变项放在元组中。

*   扩充赋值不是原子操作——我们刚刚看到它在完成部分工作后抛出异常。

*   检查 Python 字节码并不太难，而且有助于了解幕后发生了什么。

在见证了使用`+`和`*`进行连接的微妙之处之后，我们可以将主题转换到序列的另一个基本操作:排序。

# list.sort 与排序的内置

`list.sort`方法就地对列表进行排序——也就是说，不进行复制。它返回`None`来提醒我们它改变了接收者 [11] 并且没有创建新的列表。这是一个重要的 Python API 约定:就地改变对象的函数或方法应该返回`None`,以向调用者清楚地表明接收者被改变了，并且没有创建新的对象。例如，在`random.shuffle(s)`函数中可以看到类似的行为，它将可变序列`s`打乱，然后返回`None`。

###### 注意

返回`None`来通知就地更改的约定有一个缺点:我们不能级联对这些方法的调用。相反，返回新对象的方法(例如，所有的`str`方法)可以在 fluent 接口风格中级联。参见维基百科的[“流畅界面”条目](https://fpy.li/2-15)了解关于这个话题的进一步描述。

相反，内置函数`sorted`创建一个新的列表并返回它。它接受任何可迭代对象作为参数，包括不可变序列和生成器(见第 17 章)。不管给`sorted`的 iterable 是什么类型，它总是返回一个新创建的列表。

`list.sort`和`sorted`都有两个可选的、只有关键字的参数:

`reverse`

如果`True`，则按降序返回项目(即通过反转项目的比较)。默认为`False`。

`key`

一个单参数函数，将应用于每个项目以生成其排序关键字。例如，在对字符串列表进行排序时，可以使用`key=str.lower`来执行不区分大小写的排序，而`key=len`将按照字符长度对字符串进行排序。默认为 identity 函数(即物品本身与和进行比较)。

###### 小费

您也可以将可选关键字参数`key`用于内置的`min()`和`max()`以及标准库中的其他函数(例如`itertools.groupby()`和`heapq.nlargest()`)。

这里有几个例子来说明这些函数和关键字参数的用法。这些示例还展示了 Python 的排序算法是稳定的(即，它保留了进行同等比较的项目的相对顺序): [12]

```
>>> fruits=['grape','raspberry','apple','banana']>>> sorted(fruits)['apple', 'banana', 'grape', 'raspberry'] ①>>> fruits['grape', 'raspberry', 'apple', 'banana'] ②>>> sorted(fruits,reverse=True)['raspberry', 'grape', 'banana', 'apple'] ③>>> sorted(fruits,key=len)['grape', 'apple', 'banana', 'raspberry'] ④>>> sorted(fruits,key=len,reverse=True)['raspberry', 'banana', 'grape', 'apple'] ⑤>>> fruits['grape', 'raspberry', 'apple', 'banana'] ⑥>>> fruits.sort()⑦>>> fruits['apple', 'banana', 'grape', 'raspberry'] ⑧
```

① 这将生成一个按字母顺序排序的新字符串列表。 [13]

② 检查原始列表，我们看到它没有改变。

③ 这是前面的“字母”顺序，颠倒了。

④ 一个新的字符串列表，现在按长度排序。因为排序算法是稳定的，所以长度都为 5 的“葡萄”和“苹果”是按照原来的顺序排列的。

⑤ 这些是按长度降序排列的字符串。这与前面的结果并不相反，因为排序是稳定的，所以“葡萄”再次出现在“苹果”之前

⑥ 到目前为止，原`fruits`列表的排序没有改变。

⑦ 这将对列表进行排序，并返回`None`(控制台省略了它)。

⑧ 现在`fruits`排序了。

###### 警告

默认情况下，Python 根据字符代码按字典顺序对字符串进行排序。这意味着 ASCII 大写字母将出现在小写字母之前，非 ASCII 字符不太可能以合理的方式排序。“对 Unicode 文本进行排序”涵盖了人类期望的对文本进行排序的正确方法。

一旦你的序列被排序，他们可以非常有效地搜索。Python 标准库的`bisect`模块中已经提供了二分搜索法算法。该模块还包含了`bisect.insort`函数，您可以使用它来确保排序后的序列保持有序。你会在[](http://fluentpython.com)*配套网站的[【用二分法管理有序序列】](https://fpy.li/bisect)帖子中找到关于`bisect`模块的图解介绍。*

 *到目前为止，我们在这一章看到的大部分内容都适用于一般的序列，而不仅仅是列表或元组。Python 程序员有时会过度使用`list`类型，因为它太方便了——我知道我曾经这样做过。例如，如果您正在处理大量的数字列表，您应该考虑使用数组。本章的其余部分将专门讨论列表和元组的替代方法。*  *# 当列表不是答案时

`list`类型灵活易用，但根据具体需求，还有更好的选择。例如，当您需要处理数百万个浮点值时，`array`可以节省大量内存。另一方面，如果你经常从列表的两端添加和删除条目，知道一个 `deque`(双端队列)是一个更有效的 FIFO [14] 数据结构是很好的。

###### 小费

如果您的代码经常检查集合中是否存在某个项目(例如，`item in my_collection`)，请考虑对`my_collection`使用`set`，尤其是当它包含大量项目时。集合已针对快速成员资格检查进行了优化。它们也是可迭代的，但它们不是序列，因为集合项的顺序是不确定的。我们将在第 3 章中介绍它们。

在本章的剩余部分，我们将讨论在许多情况下可以代替列表的可变序列类型，从数组开始。

## 数组

如果一个列表只包含数字，`array.array`是一个更有效的替换。数组支持所有可变序列操作(包括`.pop`、`.insert`和`.extend`，以及快速加载和保存的附加方法，如`.frombytes`和`.tofile`。

Python 数组和 C 数组一样精简。如图 2-1 中的所示，一个`float`值的`array`并不保存完整的`float`实例，而只保存代表其机器值的打包字节——类似于 C 语言中的`double`数组。当创建一个`array`时，您提供一个 typecode，一个字母来确定用于存储数组中每一项的底层 C 类型。例如，`b`是 C 称之为 a `signed char`的类型码，一个从–128 到 127 的整数。如果你创建一个`array('b')`，那么每一项都将被存储在一个字节中，并被解释为一个整数。对于大量的数字序列，这可以节省大量的内存。Python 不会让你输入任何与数组类型不匹配的数字。

示例 2-19 显示了创建、保存和加载一千万个浮点随机数的数组。

##### 示例 2-19：创建、保存和加载一个大的浮动数组

```
>>> fromarrayimportarray①>>> fromrandomimportrandom>>> floats=array('d',(random()foriinrange(10**7)))②>>> floats[-1]③0.07802343889111107 >>> fp=open('floats.bin','wb')>>> floats.tofile(fp)④>>> fp.close()>>> floats2=array('d')⑤>>> fp=open('floats.bin','rb')>>> floats2.fromfile(fp,10**7)⑥>>> fp.close()>>> floats2[-1]⑦0.07802343889111107 >>> floats2==floats⑧True
```

① 导入`array`类型。

② 从任何可迭代对象创建一个双精度浮点数组(typecode`'d'`)——在本例中是一个生成器表达式。

③ 检查数组中的最后一个数字。

④ 将数组保存到二进制文件中。

⑤ 创建一个空的双精度数组。

⑥ 从二进制文件中读取一千万个数字。

⑦ 检查数组中的最后一个数字。

⑧ 验证数组的内容是否匹配。

如你所见，`array.tofile`和`array.fromfile`都很好用。如果你尝试这个例子，你会发现它们也非常快。一个简单的实验表明，`array.fromfile`从一个用`array.tofile`创建的二进制文件中加载 1000 万个双精度浮点大约需要 0.1 秒。这比从文本文件中读取数字快了近 60 倍，后者还需要用内置的`float`解析每一行。用`array.tofile`保存比在文本文件中每行写一个浮点快 7 倍。此外，具有 1000 万个双精度值的二进制文件的大小是 80，000，000 字节(每个双精度值 8 个字节，零开销)，而对于相同的数据，文本文件有 181，515，739 个字节。

对于表示二进制数据的数值数组的特殊情况，比如光栅图像，Python 有`bytes`和`bytearray`类型，在第 4 章中讨论。

我们用表 2-3 总结这一节，比较`list`和`array.array`的特性。

Table 2-3\. Methods and attributes found in `list` or `array` (deprecated array methods and those also implemented by object are omitted for brevity)

|  | 目录 | 排列 |   |
| --- | --- | --- | --- |
| `s.__add__(s2)` | ● | ● | `s + s2`—串联 |
| `s.__iadd__(s2)` | ● | ● | `s += s2`—就地串联 |
| `s.append(e)` | ● | ● | 在最后一个元素后追加一个元素 |
| `s.byteswap()` |  | ● | 交换数组中所有项的字节以进行字符顺序转换 |
| `s.clear()` | ● |  | 删除所有项目 |
| `s.__contains__(e)` | ● | ● | `e in s` |
| `s.copy()` | ● |  | 列表的浅拷贝 |
| `s.__copy__()` |  | ● | 支持`copy.copy` |
| `s.count(e)` | ● | ● | 计算元素的出现次数 |
| `s.__deepcopy__()` |  | ● | 对`copy.deepcopy`的优化支持 |
| `s.__delitem__(p)` | ● | ● | 移除位置`p`处的项目 |
| `s.extend(it)` | ● | ● | 从 iterable 中追加项目`it` |
| `s.frombytes(b)` |  | ● | 从解释为打包机器值的字节序列中追加项目 |
| `s.fromfile(f, n)` |  | ● | 从二进制文件`f`中追加`n`项，解释为打包的机器值 |
| `s.fromlist(l)` |  | ● | 从列表中追加项目；如果一个原因导致`TypeError`，则不追加任何原因 |
| `s.__getitem__(p)` | ● | ● | `s[p]`—获取位置上的项目或切片 |
| `s.index(e)` | ● | ● | 找到`e`第一次出现的位置 |
| `s.insert(p, e)` | ● | ● | 在位置`p`的项目前插入元素`e` |
| `s.itemsize` |  | ● | 每个数组项的字节长度 |
| `s.__iter__()` | ● | ● | 获取迭代器 |
| `s.__len__()` | ● | ● | `len(s)`—项目数量 |
| `s.__mul__(n)` | ● | ● | `s * n`—重复拼接 |
| `s.__imul__(n)` | ● | ● | `s *= n`—原地重复拼接 |
| `s.__rmul__(n)` | ● | ● | `n * s`—反向重复拼接 ^(一) |
| `s.pop([p])` | ● | ● | 移除并返回位置`p`处的项目(默认:最后) |
| `s.remove(e)` | ● | ● | 通过值删除第一次出现的元素`e` |
| `s.reverse()` | ● | ● | 颠倒项目的顺序 |
| `s.__reversed__()` | ● |  | 获取迭代器从最后一个到第一个扫描项目 |
| `s.__setitem__(p, e)` | ● | ● | `s[p] = e`—将`e`置于`p`位置，覆盖现有项目或切片 |
| `s.sort([key], [reverse])` | ● |  | 使用可选的关键字参数`key`和`reverse`就地排序项目 |
| `s.tobytes()` |  | ● | 在`bytes`对象中将项目作为打包的机器值返回 |
| `s.tofile(f)` |  | ● | 将项目作为打包的机器值保存到二进制文件`f` |
| `s.tolist()` |  | ● | 在`list`中将项目作为数字对象返回 |
| `s.typecode` |  | ● | 标识项目 C 类型的单字符字符串 |
| [a] 反转运算符在第 16 章的中解释。 |

###### 小费

从 Python 3.10 开始，`array`类型没有像`list.sort()`那样的就地`sort`方法。如果需要对数组进行排序，使用内置的`sorted`函数来重建数组:

```
a = array.array(a.typecode, sorted(a))
```

要在向一个已排序的数组中添加项目时保持其排序，使用 [`bisect.insort`](https://fpy.li/2-16) 函数。

如果你对数组做了很多工作，却不知道`memoryview`，那你就错过了。见下一个话题。

## 内存视图

内置的`memoryview`类是一个共享内存序列类型，它允许您在不复制字节的情况下处理数组切片。它的灵感来自 NumPy 库(我们将在“NumPy”中讨论)。NumPy 的主要作者 Travis Oliphant 回答了这个问题，[“什么时候应该使用内存视图？”](https://fpy.li/2-17)像这样:

> memoryview 本质上是 Python 本身的一个广义 NumPy 数组结构(没有数学)。它允许你在数据结构之间共享内存(像 PIL 图像、SQLite 数据库、NumPy 数组等等)。)没有先抄。这对于大型数据集非常重要。

使用类似于`array`模块的符号，`memoryview.cast`方法允许您改变多个字节作为一个单元被读取或写入的方式，而不需要移动位。`memoryview.cast`返回另一个`memoryview`对象，总是共享同一个内存。

示例 2-20 展示了如何在相同的 6 字节数组上创建替代视图，并将其作为 2×3 矩阵或 3×2 矩阵进行操作。

##### 示例 2-20：将 6 字节内存作为 1×6、2×3 和 3×2 视图进行处理

```
>>> fromarrayimportarray>>> octets=array('B',range(6))①>>> m1=memoryview(octets)②>>> m1.tolist()[0, 1, 2, 3, 4, 5] >>> m2=m1.cast('B',[2,3])③>>> m2.tolist()[[0, 1, 2], [3, 4, 5]] >>> m3=m1.cast('B',[3,2])④>>> m3.tolist()[[0, 1], [2, 3], [4, 5]] >>> m2[1,1]=22⑤>>> m3[1,1]=33⑥>>> octets⑦array('B', [0, 1, 2, 33, 22, 5])
```

① 构建 6 字节数组(类型码`'B'`)。

② 从该数组构建`memoryview`，然后将其导出为一个列表。

③ 从前一个构建新的`memoryview`，但是有`2`行和`3`列。

④ 又一个`memoryview`，现在有`3`行和`2`列。

⑤ 用`22`覆盖`m2`行`1`列`1`中的字节。

⑥ 用`33`覆盖`1`行`1`列`m3`中的字节。

⑦ 显示原始数组，证明内存由`octets`、`m1`、`m2`、`m3`共享。

`memoryview`的牛逼力量也可以用来腐败。示例 2-21 展示了如何改变一个 16 位整数数组中的一个字节。

##### 示例 2-21：通过拨动 16 位整数数组的一个字节来改变其值

```
>>> numbers=array.array('h',[-2,-1,0,1,2])>>> memv=memoryview(numbers)①>>> len(memv)5 >>> memv[0]②-2 >>> memv_oct=memv.cast('B')③>>> memv_oct.tolist()④[254, 255, 255, 255, 0, 0, 1, 0, 2, 0] >>> memv_oct[5]=4⑤>>> numbersarray('h', [-2, -1, 1024, 1, 2]) ⑥
```

① 从 5 个 16 位有符号整数的数组构建`memoryview`(类型码`'h'`)。

② `memv`在数组中看到相同的 5 个项目。

③ 通过将`memv`的元素转换成字节来创建`memv_oct`(类型码`'B'`)。

④ 将`memv_oct`的元素导出为一个 10 字节的列表，以供检查。

⑤ 将值`4`分配给字节偏移量`5`。

⑥ 注意`numbers`的变化:一个 2 字节无符号整数的最高有效字节中的`4`是`1024`。

###### 注意

你会在[](http://fluentpython.com)*:[“用 struct 解析二进制记录”](https://fpy.li/2-18)找到一个用`struct`包检查`memoryview`的例子。*

 *同时，如果您在数组中进行高级数值处理，您应该使用 NumPy 库。我们马上简要地看一下它们。*  *## NumPy

在本书中，我特别强调了 Python 标准库中已经有的东西，这样你就可以充分利用它们。但是 NumPy 太棒了，所以绕道是必要的。

对于高级数组和矩阵运算，NumPy 是 Python 成为科学计算应用主流的原因。NumPy 实现了多维、同质的数组和矩阵类型，它们不仅保存数字，还保存用户定义的记录，并提供高效的基于元素的操作。

SciPy 是一个基于 NumPy 编写的库，提供了许多科学计算算法，包括线性代数、数值微积分和统计学。SciPy 快速可靠，因为它利用了广泛使用的来自 [Netlib 库](https://fpy.li/2-19)的 C 和 Fortran 代码库。换句话说，SciPy 为科学家提供了两个世界的精华:交互式提示和高级 Python APIs，以及用 C 和 Fortran 优化的工业级数字处理功能。

作为一个非常简短的 NumPy 演示，示例 2-22 展示了二维数组的一些基本操作。

##### 示例 2-22：a 中的行和列的基本操作`numpy.ndarray`

```
>>> importnumpyasnp①>>> a=np.arange(12)②>>> aarray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]) >>> type(a)<class 'numpy.ndarray'> >>> a.shape③(12,) >>> a.shape=3,4④>>> aarray([[ 0,  1,  2,  3],
 [ 4,  5,  6,  7], [ 8,  9, 10, 11]]) >>> a[2]⑤array([ 8,  9, 10, 11]) >>> a[2,1]⑥9 >>> a[:,1]⑦array([1, 5, 9]) >>> a.transpose()⑧array([[ 0,  4,  8],
 [ 1,  5,  9], [ 2,  6, 10], [ 3,  7, 11]])
```

① 安装后导入 NumPy(它不在 Python 标准库中)。按照惯例，`numpy`作为`np`导入。

② 用整数`0`到`11`建造并检查一个`numpy.ndarray`。

③ 检查数组的维数:这是一个一维的 12 元素数组。

④ 更改数组的形状，添加一维，然后检查结果。

⑤ 获取索引`2`处的行。

⑥ 获取索引处的元素`2, 1`。

⑦ 获取索引`1`处的列。

⑧ 通过转置(用行交换列)创建一个新数组。

NumPy 还支持加载、保存和操作一个`numpy.ndarray`的所有元素的高级操作:

```
>>> importnumpy>>> floats=numpy.loadtxt('floats-10M-lines.txt')①>>> floats[-3:]②array([ 3016362.69195522,   535281.10514262,  4566560.44373946]) >>> floats*=.5③>>> floats[-3:]array([ 1508181.34597761,   267640.55257131,  2283280.22186973]) >>> fromtimeimportperf_counteraspc④>>> t0=pc();floats/=3;pc()-t0⑤0.03690556302899495 >>> numpy.save('floats-10M',floats)⑥>>> floats2=numpy.load('floats-10M.npy','r+')⑦>>> floats2*=6>>> floats2[-3:]⑧memmap([ 3016362.69195522,   535281.10514262,  4566560.44373946])
```

① 从文本文件中加载 1000 万个浮点数。

② 使用序列切片符号检查最后三个数字。

③ 将`floats`数组中的每个元素乘以`.5`，并再次检查最后三个元素。

④ 导入高分辨率性能测量计时器(从 Python 3.3 开始提供)。

⑤ 用`3`划分每个元素；1000 万次浮点运算所用的时间不到 40 毫秒。

⑥ 将数组保存在*中。npy* 二进制文件。

⑦ 将数据作为内存映射文件加载到另一个数组中；这允许有效地处理阵列的切片，即使它不完全适合内存。

⑧ 将每个元素乘以`6`后，检查最后三个元素。

这只是开胃菜。

NumPy 和 SciPy 是强大的库，也是其他强大工具的基础，如[Pandas](https://fpy.li/2-20)——它实现了高效的数组类型，可以保存非数值数据，并为许多不同的格式提供导入/导出功能，如*。csv* 、*。xls* ，SQL 转储，HDF5 等。—以及 [scikit-learn](https://fpy.li/2-21) ，目前使用最广泛的机器学习工具集。大多数 NumPy 和 SciPy 函数都是用 C 或 C++实现的，并且可以利用所有的 CPU 内核，因为它们释放了 Python 的 GIL(全局解释器锁)。Dask 项目支持跨机器集群的并行 NumPy、Pandas 和 scikit-learn 处理。这些软件包值得整本书来介绍它们。这不是那些书中的一本。但是，如果不快速浏览一下 NumPy 数组，对 Python 序列的概述将是不完整的。

看完了平面序列——标准数组和 NumPy 数组——我们现在来看一组完全不同的替代物:队列。

## 德克和其他队列

`.append`和`.pop`方法使`list`可用作堆栈或队列(如果使用`.append`和`.pop(0)`，则得到 FIFO 行为)。但是在链表头(0-索引端)插入和删除是很昂贵的，因为整个链表必须在内存中移位。

类`collections.deque`是一个线程安全的双端队列，设计用于从两端快速插入和移除。如果您需要保留一个“最后看到的项目”的列表或者类似的东西，这也是一个好办法，因为一个`deque`可以被限制——也就是说，用一个固定的最大长度来创建。如果一个有界的`deque`是满的，当你添加一个新的项目时，它会从另一端丢弃一个项目。示例 2-23 显示了在`deque`上执行的一些典型操作。

##### 示例 2-23：使用`deque`工作

```
>>> fromcollectionsimportdeque>>> dq=deque(range(10),maxlen=10)①>>> dqdeque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10) >>> dq.rotate(3)②>>> dqdeque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10) >>> dq.rotate(-4)>>> dqdeque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10) >>> dq.appendleft(-1)③>>> dqdeque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10) >>> dq.extend([11,22,33])④>>> dqdeque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10) >>> dq.extendleft([10,20,30,40])⑤>>> dqdeque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)
```

① 可选的`maxlen`参数设置`deque`实例中允许的最大项数；这将设置一个只读的`maxlen`实例属性。

② 用`n > 0`旋转从右端取项目，并将其前置到左侧；当`n < 0`项目从左侧取出并附加到右侧时。

③ 追加到已满的`deque`(`len(d) == d.maxlen`)丢弃另一端的项目；注意在下一行中`0`被删除。

④ 向右添加三个项目会推出最左边的`-1`、`1`和`2`。

⑤ 请注意，`extendleft(iter)`的工作方式是将`iter`参数的每个连续项目追加到`deque`的左侧，因此项目的最终位置是相反的。

表 2-4 比较了`list`和`deque`特有的方法(去掉了`object`中也会出现的方法)。

请注意，`deque`实现了大多数`list`方法，并添加了一些特定于其设计的方法，如`popleft`和`rotate`。但是有一个隐藏的成本:从一个`deque`中间移除项目没有那么快。它实际上是为追加和从末尾弹出而优化的。

`append`和`popleft`操作是原子的，所以`deque`在多线程应用中用作 FIFO 队列是安全的，不需要锁。

Table 2-4\. Methods implemented in `list` or `deque` (those that are also implemented by `object` are omitted for brevity)

|  | 目录 | 双端队列 |   |
| --- | --- | --- | --- |
| `s.__add__(s2)` | ● |  | `s + s2`—串联 |
| `s.__iadd__(s2)` | ● | ● | `s += s2`—就地串联 |
| `s.append(e)` | ● | ● | 向右侧追加一个元素(在最后一个之后) |
| `s.appendleft(e)` |  | ● | 向左侧追加一个元素(在第一个元素之前) |
| `s.clear()` | ● | ● | 删除所有项目 |
| `s.__contains__(e)` | ● |  | `e in s` |
| `s.copy()` | ● |  | 列表的浅拷贝 |
| `s.__copy__()` |  | ● | 支持`copy.copy`(浅拷贝) |
| `s.count(e)` | ● | ● | 计算元素的出现次数 |
| `s.__delitem__(p)` | ● | ● | 移除位置`p`处的项目 |
| `s.extend(i)` | ● | ● | 将 iterable `i`中的项目追加到右侧 |
| `s.extendleft(i)` |  | ● | 将 iterable `i`中的项目追加到左侧 |
| `s.__getitem__(p)` | ● | ● | `s[p]`—获取位置上的项目或切片 |
| `s.index(e)` | ● |  | 找到`e`第一次出现的位置 |
| `s.insert(p, e)` | ● |  | 在位置`p`的项目前插入元素`e` |
| `s.__iter__()` | ● | ● | 获取迭代器 |
| `s.__len__()` | ● | ● | `len(s)`—项目数量 |
| `s.__mul__(n)` | ● |  | `s * n`—重复拼接 |
| `s.__imul__(n)` | ● |  | `s *= n`—原地重复拼接 |
| `s.__rmul__(n)` | ● |  | `n * s`—反向重复拼接 ^(一) |
| `s.pop()` | ● | ● | 移除并返回最后一项 [b] |
| `s.popleft()` |  | ● | 移除并返回第一个项目 |
| `s.remove(e)` | ● | ● | 通过值删除第一次出现的元素`e` |
| `s.reverse()` | ● | ● | 颠倒项目的顺序 |
| `s.__reversed__()` | ● | ● | 获取迭代器从最后一个到第一个扫描项目 |
| `s.rotate(n)` |  | ● | 将`n`项目从一端移动到另一端 |
| `s.__setitem__(p, e)` | ● | ● | `s[p] = e`—将`e`置于`p`位置，覆盖现有项目或切片 |
| `s.sort([key], [reverse])` | ● |  | 使用可选的关键字参数`key`和`reverse`就地排序项目 |
| [a] 反转运算符在第 16 章中解释。[b] `a_list.pop(p)`允许从位置`p`移除，但`deque`不支持该选项。 |

除了 `deque`，其他 Python 标准库包都实现了队列:

`queue`

这提供了同步的(即线程安全的)类`SimpleQueue`、`Queue`、`LifoQueue`和`PriorityQueue`。这些可以用于线程之间的安全通信。通过向构造函数提供一个大于 0 的参数`maxsize`，可以对除了`SimpleQueue`之外的所有参数进行绑定。然而，他们不会像`deque`那样丢弃物品来腾出空间。相反，当队列已满时，新项目的插入会被阻止，即，它会等待，直到其他线程从队列中取出一个项目来腾出空间，这有助于限制活动线程的数量。

`multiprocessing`

实现自己的无界`SimpleQueue`和有界`Queue`，非常类似于`queue`包中的那些，但是是为进程间通信设计的。专门的`multiprocessing.JoinableQueue`用于任务管理。

`asyncio`

为 `Queue`、`LifoQueue`、`PriorityQueue`和`JoinableQueue`提供受`queue`和`multiprocessing`模块中的类启发的 API，但适用于管理异步编程中的任务。

`heapq`

在中，与前三个模块不同的是，`heapq`没有实现队列类，但是提供了像`heappush`和`heappop`这样的函数，允许您使用可变序列作为堆队列或优先级队列。

这就结束了我们对`list`类型替代方案的概述，也结束了我们对序列类型的一般探索——除了`str`和二元序列的细节，它们有自己的章节(第 4 章)。*  *# 章节摘要

掌握标准库序列类型是编写简洁、有效和惯用的 Python 代码的先决条件。

Python 序列通常被归类为可变的或不可变的，但是考虑不同的轴也是有用的:平面序列和容器序列。前者更紧凑、更快、更易于使用，但仅限于存储原子数据，如数字、字符和字节。容器序列更加灵活，但是当它们包含可变对象时，可能会让您感到惊讶，所以您需要小心地将它们正确用于嵌套数据结构。

不幸的是，Python 没有万无一失的不可变容器序列类型:即使是“不可变”元组，当它们包含可变项(如列表或用户定义的对象)时，它们的值也可以改变。

列表理解和生成器表达式是构建和初始化序列的强大符号。如果你还不习惯使用它们，花点时间掌握它们的基本用法。不难，很快你就会上瘾。

Python 中的元组扮演两个角色:作为具有未命名字段的记录和作为不可变列表。当使用元组作为不可变列表时，请记住，只有当元组中的所有项都不可变时，元组值才能保证是固定的。对 tuple 调用`hash(t)`是断言其值是固定的快速方法。如果`t`包含可变项，将引发一个`TypeError`。

当元组用作记录时，元组解包是提取元组字段的最安全、最可读的方式。除了元组，`*`在许多上下文中使用列表和可重复项，它的一些用例出现在 Python 3.5 中，带有[PEP 448——额外的解包一般化](https://fpy.li/pep448)。Python 3.10 引入了带有`match/case`的模式匹配，支持更强大的解包，称为析构。

序列切片是最受欢迎的 Python 语法特性，它甚至比许多人意识到的还要强大。NumPy 中使用的多维切片和省略号(`...`)符号也可以被用户定义的序列所支持。分配给切片是编辑可变序列的一种非常有表现力的方式。

像在`seq * n`中一样的重复连接是方便的，并且如果小心的话，可以用来初始化包含不可变条目的列表。对于可变序列和不可变序列，使用`+=`和`*=`的扩充赋值表现不同。在后一种情况下，这些操作符必须建立新的序列。但是如果目标序列是可变的，它通常会被就地改变——但并不总是如此，这取决于序列是如何实现的。

`sort`方法和`sorted`内置函数易于使用且灵活，这要归功于可选的`key`参数:一个计算排序标准的函数。顺便说一下，`key`也可以与`min`和`max`内置函数一起使用。

除了列表和元组，Python 标准库还提供了`array.array`。尽管 NumPy 和 SciPy 不是标准库的一部分，但是如果您要对大量数据进行任何类型的数值处理，那么即使研究这些库中的一小部分也会让您受益匪浅。

最后，我们访问了通用且线程安全的`collections.deque`，将它的 API 与表 2-4 中的`list`进行了比较，并提到了标准库中的其他队列实现。

# 进一步阅读

第三版 *Python 指南*的第](https://fpy.li/pycook3) 1 章“数据结构”。大卫·比兹利和布莱恩·k·琼斯(Brian K. Jones)的《奥莱利》(O'Reilly)有许多专注于序列的配方，包括“配方 1.11”。命名一个片”，从中我学到了将片分配给变量以提高可读性的技巧，在我们的[示例 2-13 中有说明。

Python 烹饪书*的第二版*是为 Python 2.4 编写的，但是它的大部分代码适用于 Python 3，第 5 章和第 6 章中的很多食谱都是关于序列的。这本书由亚历克斯·马尔泰利、安娜·拉文斯克罗夫特和大卫·阿舍尔编辑，其中包括几十位皮达尼斯的贡献。第三版从零开始重写，更加关注语言的语义——特别是 Python 3 中的变化——而旧版本强调语用学(即如何将语言应用于现实世界的问题)。即使一些第二版的解决方案不再是最好的方法，我真诚地认为手头上有这两个版本的 Python 食谱*是值得的。*

官方 Python[“Sorting HOW TO”](https://fpy.li/2-22)有几个使用`sorted`和`list.sort`的高级技巧的例子。

[PEP 3132—扩展的可迭代解包](https://fpy.li/2-2)是阅读并行赋值左侧`*extra`语法新用法的权威来源。如果你想了解 Python 的发展，[“Missing *-unpacking generations”](https://fpy.li/2-24)是一个 bug tracker 问题，提出了对 iterable 解包符号的增强。[PEP 448——额外的拆包概括](https://fpy.li/pep448)来自该问题的讨论。

正如我在“序列模式匹配”中提到的，Carol Willing 的[“结构模式匹配”](https://fpy.li/2-6)部分的[“Python 3.10 中的新特性”](https://fpy.li/2-7)是对这个主要新特性的一个很好的介绍，大约 1400 字(当 Firefox 从 HTML 制作 PDF 时不到 5 页)。[PEP 636—结构模式匹配:教程](https://fpy.li/pep636)也不错，但是比较长。同样的 PEP 636 包括[“附录 A—快速介绍”](https://fpy.li/2-27)。它比 Willing 的介绍要短，因为它省略了为什么模式匹配对您有好处的高级考虑。如果你需要更多的论据来说服自己或他人模式匹配对 Python 有好处，请阅读 22 页的[PEP 635—结构化模式匹配:动机和基本原理](https://fpy.li/pep635)。

Eli Bendersky 的博客文章[“使用缓冲协议和内存视图减少 Python 中的副本”](https://fpy.li/2-28)包括一个关于`memoryview`的简短教程。

市面上涉及 NumPy 的书籍数不胜数，很多都没有在书名中提到“NumPy”。两个例子是 Jake VanderPlas 的 open access [*Python 数据科学手册*](https://fpy.li/2-29) 和 Wes McKinney 的第二版[*Python for Data Analysis*](https://fpy.li/2-30)。

“NumPy 完全是关于矢量化的。”那是尼古拉斯·p·罗杰尔《从 Python 到 NumPy 的开放存取书 [*的开篇句子。矢量化运算将数学函数应用于数组的所有元素，而无需使用 Python 编写的显式循环。它们可以并行操作，使用现代 CPU 中的特殊向量指令，利用多个内核或委托给 GPU，具体取决于库。罗杰尔书中的第一个例子显示，在使用生成器方法将一个漂亮的 Pythonic 类重构为一个调用几个 NumPy 向量函数的精简函数后，速度提高了 500 倍。*](https://fpy.li/2-31)

要了解如何使用`deque`(和其他集合)，请参见 Python 文档中[“容器数据类型”](https://fpy.li/collec)中的示例和实用方法。

Edsger W. Dijkstra 自己写了一篇名为[“为什么编号应该从零开始”](https://fpy.li/2-32)的简短备忘录，对 Python 排除范围和切片中最后一项的约定进行了最好的辩护。备忘录的主题是数学符号，但它与 Python 有关，因为 Dijkstra 严谨而幽默地解释了为什么像 2，3，…，12 这样的序列应该总是表示为 2 ≤ i < 13。所有其他合理的约定都被驳斥，让每个用户选择一个约定的想法也是如此。标题指的是从零开始的索引，但备忘录实际上是关于为什么`'ABCDE'[1:3]`表示`'BC'`而不是`'BCD'`是可取的，以及为什么写`range(2, 13)`产生 2，3，4，…，12 是完全合理的。顺便说一下，备忘录是手写的，但它很漂亮，完全可读。Dijkstra 的笔迹如此清晰，以至于有人用他的笔记创造了一个[字体](https://fpy.li/2-33)。

[1] Leo Geurts，Lambert Meertens，和 Steven Pemberton， *ABC 程序员手册*，第 8 页。(博斯科图书公司)。

感谢读者 Tina Lapine 指出这一点。

感谢科技评论家莱昂纳多·罗歇尔给我们举了这个例子。

[4] 在我看来，`if/elif/elif/.../else`块的序列是对`switch/case`的一个很好的替代。它不会遭受一些语言设计者不合理地从 C 语言中复制的 [fallthrough](https://fpy.li/2-8) 和 [dangling else](https://fpy.li/2-9) 问题——几十年前，它们被广泛认为是无数错误的原因。

[5] 后者在诺威格的代号中被命名为`eval`；我重命名它是为了避免与 Python 的`eval`内置混淆。

^(6](ch02.xhtml#idm46582493669184-marker)) 在[“内存视图”中，我们展示了专门构造的内存视图可以有多个维度。

[7] 不，我没有弄错:`ellipsis`类名实际上都是小写的，实例是一个名为`Ellipsis`的内置实例，就像`bool`是小写的，但它的实例是`True`和`False`。

[8] `str`是这种描述的例外。因为在循环中使用`+=`构建字符串在实际代码库中非常常见，所以 CPython 针对这个用例进行了优化。`str`的实例在内存中被分配了额外的空间，因此串联不需要每次都复制整个字符串。

[9] 感谢莱昂纳多·罗凯尔和塞萨尔·川上在 2013 年 PythonBrasil 大会上分享了这个谜语。

[10] 读者建议，例子中的操作可以用`t[2].extend([50,60])`完成，不会出错。我知道这一点，但我的目的是展示在这种情况下`+=`操作符的奇怪行为。

[11] 接收者是方法调用的目标，该对象绑定到方法体中的`self`。

^(12](ch02.xhtml#idm46582495259904-marker)) Python 的主要排序算法以其创造者蒂姆·彼得斯(Tim Peters)命名为 Timsort。关于 Timsort 的一些琐事，请参见[“肥皂盒”。

[13] 本例中的单词按字母顺序排序，因为它们 100%由小写 ASCII 字符组成。请参见示例后的警告。

[14] 先进先出——队列的默认行为。**